name: Release

on:
    push:
        branches: [main]

jobs:
    release:
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  tags: true

            - name: Find CRLF in shell scripts
              run: |
                find . -type f -name "*.sh" -exec sed -i 's/\r$//' {} \;

            - name: Install build tools (Linux)
              if: matrix.os == 'ubuntu-latest'
              run: sudo apt-get update && sudo apt-get install -y build-essential ruby ruby-dev rubygems

            - name: Install build tools (macOS)
              if: matrix.os == 'macos-latest'
              run: brew install gcc ruby

            - name: Install fpm
              run: sudo gem install --no-document fpm

            - name: Build binary
              run: gcc -O2 -Wall -Wextra -o initx main.c

            - name: Package (deb for Linux)
              if: matrix.os == 'ubuntu-latest'
              run: |
                fpm -s dir -t deb \
                    -n initx \
                    -v "${GITHUB_REF_NAME#v}" \
                    --prefix /usr/local/bin \
                    ./initx

            - name: Package (tar.gz for macOS)
              if: matrix.os == 'macos-latest'
              run: |
                mkdir -p dist
                cp initx dist/
                tar -czf initx-${GITHUB_REF_NAME#v}-macos.tar.gz -C dist initx

            - name: Upload packages
              uses: actions/upload-artifact@v4
              with:
                name: packages-${{ matrix.os }}
                path: "*.deb,*.tar.gz"

            - name: Set up Git
              run: |
                  git config user.name "github-actions"
                  git config user.email "github-actions@github.com"

            - name: Get current date
              id: date
              run: echo "date=$(date +'%Y/%m/%d')" >> $GITHUB_OUTPUT

            - name: Get next version tag
              id: version
              run: |
                  latest=$(git tag --sort=-v:refname | grep '^v' | head -n 1)
                  echo "Последний тег: $latest"

                  if [ -z "$latest" ]; then
                    version="v0.1.0"
                  else
                    raw_version=${latest#v}
                    major=$(echo "$raw_version" | cut -d. -f1)
                    minor=$(echo "$raw_version" | cut -d. -f2)
                    patch=$(echo "$raw_version" | cut -d. -f3)

                    bug_count=0
                    dependencies_count=0

                    issues=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                      "https://api.github.com/repos/${{ github.repository }}/issues?state=closed&per_page=100")

                    bug_count=$(echo "$issues" | jq '[.[] | select(.labels? != null) | select((.labels[]?.name // "") == "bug")] | length')
                    dependencies_count=$(echo "$issues" | jq '[.[] | select(.labels? != null) | select((.labels[]?.name // "") == "dependencies")] | length')

                    if [ $bug_count -gt 0 ] || [ $dependencies_count -gt 0 ]; then
                      patch=$((patch + bug_count + dependencies_count))
                    fi

                    minor=$((minor + 1))
                    version="v$major.$minor.$patch"
                  fi

                  echo "version=$version" >> $GITHUB_OUTPUT

            - name: Create tag
              run: |
                  git tag ${{ steps.version.outputs.version }}
                  git push origin ${{ steps.version.outputs.version }}

            - name: Generate changelog from merged PRs and closed issues
              id: changelog
              uses: actions/github-script@v7
              with:
                  script: |
                      const currentVersion = "${{ steps.version.outputs.version }}";
                        const { data: releases } = await github.rest.repos.listReleases({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                        });

                        const lastRelease = releases.find(r => !r.prerelease && r.tag_name !== currentVersion);
                        let since;
                        if (lastRelease) {
                            since = new Date(lastRelease.created_at).toISOString();
                        } else {
                            since = "1970-01-01T00:00:00Z";
                        }

                        const { data: pulls } = await github.rest.pulls.list({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            state: "closed",
                            sort: "updated",
                            direction: "desc",
                            per_page: 100
                        });
                        const mergedPRs = pulls.filter(pr => pr.merged_at && pr.merged_at > since);
                        const prChangelog = mergedPRs.map(pr => `- ${pr.title} (#${pr.number})`).join("\n");

                        const { data: issues } = await github.rest.issues.listForRepo({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            state: "closed",
                            sort: "updated",
                            direction: "desc",
                            per_page: 100
                        });

                        const closedIssues = issues.filter(issue => !issue.pull_request && new Date(issue.closed_at) > new Date(since));

                        const labelGroups = {};
                        closedIssues.forEach(issue => {
                          if (issue.labels.length === 0) {
                            if (!labelGroups["Other"]) labelGroups["Other"] = [];
                            labelGroups["Other"].push(issue);
                          } else {
                            issue.labels.forEach(label => {
                              const name = label.name;
                              if (!labelGroups[name]) labelGroups[name] = [];
                              labelGroups[name].push(issue);
                            });
                          }
                        });

                        let issueChangelogByLabel = "";
                        const labelTitles = {
                          new: "## Enhancements",
                          bug: "## Bug Fixes",
                          git: "## Git",
                          Other: "## Other"
                        };

                        for (const [label, items] of Object.entries(labelGroups)) {
                          const title = labelTitles[label] || `## ${label.charAt(0).toUpperCase() + label.slice(1)}`;
                          const list = items.map(issue => `- ${issue.title} (#${issue.number})`).join("\n");
                          issueChangelogByLabel += `${title}\n\n${list}\n\n`;
                        }

                        core.setOutput("changelog_pr", prChangelog);
                        core.setOutput("changelog_issues_by_label", issueChangelogByLabel.trim());

            - name: Create GitHub Release
              uses: softprops/action-gh-release@v1
              with:
                  tag_name: ${{ steps.version.outputs.version }}
                  name: '${{ steps.version.outputs.version }}'
                  body: |
                      ## initx - generating basic project architectures

                      > A new version of initx is available `${{ steps.version.outputs.version }}`! A lightweight cli tool for generating basic project architectures for different programming languages.

                      initx is designed to streamline the initial setup of new projects by providing a simple command-line interface that scaffolds basic project structures. Whether you're starting a project in Go, Python, or any other supported language, initx helps you get started quickly with minimal configuration.

                      ## Usage

                        ```bash
                        usage: initx [-v | --version] [-h | --help] [-l | --languages]
                                    [-s | --scopes] [--directory='current | new']
                                    <command> [<args>]

                        working with architecture creation:
                        initx [language] [project-name] [scope]
                        ```

                        ## Supported languages

                        | Language | Icon |
                        |----------|-------|
                        | [Go](https://go.dev/) | <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/go/go-original.svg" width="40" alt="Go" /> |
                        | [C](https://en.wikipedia.org/wiki/C_(programming_language)) | <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/c/c-original.svg" width="40" alt="C" /> |

                      ${{ steps.changelog.outputs.changelog_issues_by_label }}

                      ### Pull Requests

                      ${{ steps.changelog.outputs.changelog_pr }}

                      [©thefuture-industries](https://github.com/thefuture-industries)
                  files: |
                        *.deb
                        *.tar.gz

            - name: Create new branch for next version
              run: |
                  raw_version="${{ steps.version.outputs.version }}"
                  raw_version=${raw_version#v}
                  major=$(echo "$raw_version" | cut -d. -f1)
                  minor=$(echo "$raw_version" | cut -d. -f2)

                  next_minor=$((minor + 1))
                  next_version="v$major.$next_minor.x"

                  git checkout -b "$next_version"
                  git push origin "$next_version" || git push origin "$next_version"